import { AST, ASTNode, ASTFunction, ASTVariable } from '../types/ast';

export interface GeneratedCode {
	filename: string;
	content: string;
	language: 'typescript' | 'javascript';
	metadata: {
		generatedAt: number;
		totalLines: number;
		totalFunctions: number;
		totalVariables: number;
		entryPoints: string[];
	};
}

export class TypeScriptGenerator {
	private ast: AST;
	private options: {
		includeComments: boolean;
		includeImports: boolean;
		useTypeScript: boolean;
		outputFormat: 'module' | 'script';
	};

	constructor(ast: AST, options = {}) {
		this.ast = ast;
		this.options = {
			includeComments: true,
			includeImports: true,
			useTypeScript: true,
			outputFormat: 'module',
			...options
		};
	}

	generateCode(): GeneratedCode {
		const code = this.buildCode();
		const filename = this.generateFilename();

		return {
			filename,
			content: code,
			language: this.options.useTypeScript ? 'typescript' : 'javascript',
			metadata: {
				generatedAt: Date.now(),
				totalLines: code.split('\n').length,
				totalFunctions: this.ast.functions.length,
				totalVariables: this.ast.variables.length,
				entryPoints: this.ast.entryPoints
			}
		};
	}

	private buildCode(): string {
		const sections: string[] = [];

		// Header comment
		if (this.options.includeComments) {
			sections.push(this.generateHeader());
		}

		// Imports
		if (this.options.includeImports && this.ast.variables.length > 0) {
			sections.push(this.generateImports());
		}

		// Variables
		if (this.ast.variables.length > 0) {
			sections.push(this.generateVariables());
		}

		// Functions
		if (this.ast.functions.length > 0) {
			sections.push(this.generateFunctions());
		}

		// Main execution flow
		sections.push(this.generateMainFlow());

		// Export section
		if (this.options.outputFormat === 'module') {
			sections.push(this.generateExports());
		}

		return sections.join('\n\n');
	}

	private generateHeader(): string {
		const timestamp = new Date().toISOString();
		return `/*
 * Generated by Logos Visual Compiler
 * Source: ${this.ast.metadata.sourceCanvas}
 * Generated: ${timestamp}
 * Complexity: ${this.ast.metadata.complexity}
 * Nodes: ${this.ast.metadata.totalNodes}, Edges: ${this.ast.metadata.totalEdges}
 * 
 * Mathematical Structure:
 * - Observer Node: Identity Element at Origin
 * - Node Classification: Division Algebra Operations
 * - Assembly Mapping: JMP/CALL, ADD/SUB, MUL/DIV, etc.
 * - Dimension: Up to 7D (Octonionic)
 */`;
	}

	private generateImports(): string {
		// For now, minimal imports - can be extended based on requirements
		const imports: string[] = [];
		
		if (this.ast.variables.some(v => v.type === 'any[]')) {
			imports.push("import { Array } from 'typescript';");
		}

		return imports.length > 0 ? imports.join('\n') : '// No external imports required';
	}

	private generateVariables(): string {
		const sections: string[] = ['// Variables'];
		
		this.ast.variables.forEach(variable => {
			const typeAnnotation = this.options.useTypeScript ? `: ${variable.type}` : '';
			const initializer = variable.value ? ` = ${variable.value}` : '';
			const comment = `// ${variable.scope} variable`;
			
			let declaration = `let ${variable.name}${typeAnnotation}${initializer};`;
			
			if (this.options.includeComments) {
				declaration = `${comment}\n${declaration}`;
			}
			
			sections.push(declaration);
		});

		return sections.join('\n');
	}

	private generateFunctions(): string {
		const sections: string[] = ['// Functions'];

		this.ast.functions.forEach(func => {
			const functionCode = this.generateFunction(func);
			sections.push(functionCode);
		});

		return sections.join('\n');
	}

	private generateFunction(func: ASTFunction): string {
		const params = func.parameters.map(param => {
			const typeAnnotation = this.options.useTypeScript ? ': number' : '';
			return `${param}${typeAnnotation}`;
		}).join(', ');

		const returnType = this.options.useTypeScript ? `: ${func.returnType}` : '';
		const asyncPrefix = func.returnType === 'Promise<any>' ? 'async ' : '';

		let functionCode = `${asyncPrefix}function ${func.name}(${params})${returnType} {`;

		// Function body
		if (func.body && func.body.length > 0) {
			const bodyLines = func.body.map(line => {
				if (line.startsWith('#')) {
					return this.convertCanvasDirectiveToCode(line);
				}
				return `  // ${line}`;
			});
			functionCode += '\n' + bodyLines.join('\n');
		} else {
			// Generate default implementation based on operation type
			const implementation = this.generateDefaultImplementation(func);
			functionCode += '\n' + implementation;
		}

		functionCode += '\n}';

		// Add assembly comment
		if (func.assemblyTemplate) {
			const assemblyComment = `\n/* Assembly Equivalent: ${func.assemblyTemplate} */`;
			functionCode += assemblyComment;
		}

		return functionCode;
	}

	private generateDefaultImplementation(func: ASTFunction): string {
		const name = func.name.toLowerCase();
		
		if (name.includes('activate') || name.includes('main')) {
			return `  // Entry point function\n  console.log("Executing ${func.name}");\n  // Call dependent functions`;
		} else if (name.includes('integrate')) {
			const [a, b] = func.parameters;
			return `  // Integrate: ${func.operation}\n  return ${a} + ${b};`;
		} else if (name.includes('transform')) {
			const [a, b] = func.parameters;
			return `  // Transform: ${func.operation}\n  return ${a} * ${b};`;
		} else if (name.includes('propagate')) {
			const [value, shift] = func.parameters;
			return `  // Propagate: ${func.operation}\n  return ${value} << ${shift};`;
		} else if (name.includes('verify')) {
			const [a, b] = func.parameters;
			return `  // Verify: ${func.operation}\n  return ${a} === ${b};`;
		} else if (name.includes('store')) {
			const [value, location] = func.parameters;
			return `  // Store: ${func.operation}\n  // Store ${value} at ${location}`;
		} else if (name.includes('observe')) {
			const [target] = func.parameters;
			return `  // Observe: ${func.operation}\n  return ${target}; // Identity operation`;
		} else {
			return `  // Default implementation\n  // TODO: Implement ${func.name}\n  return null;`;
		}
	}

	private convertCanvasDirectiveToCode(directive: string): string {
		const lines = directive.split('\n');
		const firstLine = lines[0].trim();
		
		if (firstLine.startsWith('#Activate:')) {
			const target = firstLine.substring(10).trim();
			return `  // Activate: ${target}\n  ${target}();`;
		} else if (firstLine.startsWith('#Integrate:')) {
			const operands = firstLine.substring(11).trim();
			const [a, b] = operands.split(/\s+/);
			return `  // Integrate: ${operands}\n  const result = ${a} + ${b};`;
		} else if (firstLine.startsWith('#Transform:')) {
			const operands = firstLine.substring(12).trim();
			const [a, b] = operands.split(/\s+/);
			return `  // Transform: ${operands}\n  const result = ${a} * ${b};`;
		} else if (firstLine.startsWith('#Store:')) {
			const target = firstLine.substring(7).trim();
			return `  // Store: ${target}\n  // Store result in ${target}`;
		} else if (firstLine.startsWith('#Observe:')) {
			const target = firstLine.substring(9).trim();
			return `  // Observe: ${target}\n  // Read value from ${target}`;
		}
		
		return `  // ${directive}`;
	}

	private generateMainFlow(): string {
		const sections: string[] = ['// Main execution flow'];

		if (this.ast.entryPoints.length > 0) {
			const entryPoint = this.ast.nodes.find(node => 
				this.ast.entryPoints.includes(node.id)
			);
			
			if (entryPoint) {
				sections.push(`// Starting from entry point: ${entryPoint.type}`);
				
				if (entryPoint.type === 'activate') {
					const funcName = entryPoint.operands[0] || 'main';
					sections.push(`${funcName}();`);
				} else {
					sections.push(`// Entry point: ${entryPoint.type}`);
					sections.push(`// TODO: Implement entry point logic`);
				}
			}
		}

		// Add execution trace comment
		sections.push('\n/* Execution Flow:');
		this.ast.edges.forEach(edge => {
			const fromNode = this.ast.nodes.find(n => n.id === edge.from);
			const toNode = this.ast.nodes.find(n => n.id === edge.to);
			if (fromNode && toNode) {
				sections.push(` * ${fromNode.type}(${edge.from}) â†’ ${toNode.type}(${edge.to})`);
			}
		});
		sections.push(' */');

		return sections.join('\n');
	}

	private generateExports(): string {
		const sections: string[] = ['// Module exports'];

		// Export functions
		this.ast.functions.forEach(func => {
			sections.push(`export { ${func.name} };`);
		});

		// Export variables if they're useful
		const exportableVars = this.ast.variables.filter(v => v.scope !== 'local');
		if (exportableVars.length > 0) {
			const varNames = exportableVars.map(v => v.name).join(', ');
			sections.push(`export { ${varNames} };`);
		}

		return sections.join('\n');
	}

	private generateFilename(): string {
		const canvasName = this.ast.metadata.sourceCanvas.replace(/[^a-zA-Z0-9]/g, '-');
		const timestamp = Date.now();
		const extension = this.options.useTypeScript ? 'ts' : 'js';
		
		return `${canvasName}-${timestamp}.${extension}`;
	}

	// Utility methods for different output formats

	generateES6Module(): GeneratedCode {
		const generator = new TypeScriptGenerator(this.ast, {
			...this.options,
			outputFormat: 'module'
		});
		return generator.generateCode();
	}

	generateCommonJS(): GeneratedCode {
		const generator = new TypeScriptGenerator(this.ast, {
			...this.options,
			outputFormat: 'script'
		});
		const code = generator.generateCode();
		
		// Convert ES6 exports to CommonJS
		const commonjsCode = code.content
			.replace(/export { (.+) };/g, 'module.exports = { $1 };')
			.replace(/export { (.+) } from ['"](.+)['"];/g, 'const { $1 } = require("$2");');
		
		return {
			...code,
			content: commonjsCode
		};
	}

	generateDocumentation(): string {
		const sections: string[] = ['# Generated Code Documentation'];

		sections.push('## Overview');
		sections.push(`Generated from canvas: ${this.ast.metadata.sourceCanvas}`);
		sections.push(`Complexity: ${this.ast.metadata.complexity}`);
		sections.push(`Total nodes: ${this.ast.metadata.totalNodes}`);

		if (this.ast.functions.length > 0) {
			sections.push('\n## Functions');
			this.ast.functions.forEach(func => {
				sections.push(`### ${func.name}(${func.parameters.join(', ')})`);
				sections.push(`- Returns: ${func.returnType}`);
				sections.push(`- Assembly: ${func.assemblyTemplate}`);
				if (func.body && func.body.length > 0) {
					sections.push(`- Body: ${func.body.join(' ')}`);
				}
				sections.push('');
			});
		}

		if (this.ast.variables.length > 0) {
			sections.push('\n## Variables');
			this.ast.variables.forEach(variable => {
				sections.push(`- **${variable.name}**: ${variable.type} (${variable.scope})`);
			});
		}

		return sections.join('\n');
	}
}
