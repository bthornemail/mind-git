#lang racket

;; Logos Racket Backend Server
;; Provides HTTP API for compiling AST to Racket code
;; Implements mathematical foundations: division algebras, Hopf fibrations, Eâ‚ˆ lattice

(require web-server/servlet
         web-server/servlet-env
         web-server/http
         json
         racket/port
         racket/date
         racket/pretty
         racket/list
         racket/string
         racket/math)

;; =================================================================
;; CODE GENERATION ENDPOINTS
;; =================================================================

;; Generate Racket code from AST
(define (generate-code-endpoint request)
  (let* ([body (request-body request)]
         [json-bytes (port->bytes body)]
         [ast-data (bytes->jsexpr json-bytes)])
    (with-handlers ([exn:fail? (lambda (e)
                                (response/full
                                 500
                                 #"Internal Server Error"
                                 (list (header #"Content-Type" #"application/json"))
                                 (list (jsexpr->bytes 
                                        (hasheq 'error (exn-message e)
                                               'success #f)))))])
      (let* ([racket-code (compile-ast-to-racket ast-data)]
             [result (hasheq 'success #t
                            'code racket-code
                            'metadata (hasheq 'language 'racket
                                            'lines (length (string-split racket-code "\n"))
                                            'timestamp (current-seconds)))])
        (response/full
         200
         #"OK"
         (list (header #"Content-Type" #"application/json")
               (header #"Access-Control-Allow-Origin" #"*")
               (header #"Access-Control-Allow-Methods" #"POST, OPTIONS")
               (header #"Access-Control-Allow-Headers" #"Content-Type"))
         (list (jsexpr->bytes result)))))))

;; Handle CORS preflight requests
(define (cors-endpoint request)
  (response/full
   200
   #"OK"
   (list (header #"Access-Control-Allow-Origin" #"*")
         (header #"Access-Control-Allow-Methods" #"POST, OPTIONS")
         (header #"Access-Control-Allow-Headers" #"Content-Type"))
   empty))

;; Check server health
(define (health-endpoint request)
  (let ([result (hasheq 'status 'healthy
                       'timestamp (current-seconds)
                       'version "1.0.0")])
    (response/full
     200
     #"OK"
     (list (header #"Content-Type" #"application/json")
           (header #"Access-Control-Allow-Origin" #"*"))
     (list (jsexpr->bytes result)))))

;; =================================================================
;; RACKET CODE GENERATOR
;; =================================================================

;; Convert JSON AST to Racket code
(define (compile-ast-to-racket ast-data)
  (let* ([nodes (hash-ref ast-data 'nodes '())]
         [edges (hash-ref ast-data 'edges '())]
         [functions (hash-ref ast-data 'functions '())]
         [variables (hash-ref ast-data 'variables '())]
         [metadata (hash-ref ast-data 'metadata '())])
    
    (string-append
     "#lang racket\n\n"
     ";; Generated by Logos Visual Compiler\n"
     ";; CanvasL Mathematical Architecture\n"
     ";; Hopf Fibrations: Sâ¿ â†’ Sáµ with fiber Sáµ\n\n"
     
     ;; Imports
     "(require racket/match\n"
     "         racket/list\n"
     "         racket/math\n"
     "         racket/function\n"
     "         racket/hash)\n\n"
     
     ;; Variables section
     (generate-variables-section variables)
     "\n"
     
     ;; Helper functions for mathematical operations
     (generate-math-helpers)
     "\n"
     
     ;; Node functions
     (generate-node-functions nodes edges)
     "\n"
     
     ;; Main function orchestrations
     (generate-main-functions functions)
     "\n"
     
     ;; Entry points
     (generate-entry-points (hash-ref ast-data 'entryPoints '())))))

;; Generate variable definitions
(define (generate-variables-section variables)
  (if (empty? variables)
      ";; No variables defined\n"
      (string-append
       ";; ================================\n"
       ";; Variable Definitions\n"
       ";; ================================\n"
       (apply string-append
              (map (lambda (var)
                     (format "\n(define ~a ~a)\n;; Type: ~a, Scope: ~a\n"
                             (string->symbol (hash-ref var 'name))
                             (hash-ref var 'value "#f")
                             (hash-ref var 'type "any")
                             (hash-ref var 'scope "global")))
                   variables)))))

;; Generate mathematical helper functions
(define (generate-math-helpers)
  (string-append
   ";; ================================\n"
   ";; Mathematical Helper Functions\n"
   ";; ================================\n\n"
   
   ;; Division algebra helpers
   "(define (norm-squared v)\n"
   "  \"Calculate the squared norm of a vector\"\n"
   "  (apply + (map (lambda (x) (* x x)) v)))\n\n"
   
   "(define (normalize v)\n"
   "  \"Normalize a vector to unit length\"\n"
   "  (let ([norm (sqrt (norm-squared v))])\n"
   "    (if (> norm 0)\n"
   "        (map (lambda (x) (/ x norm)) v)\n"
   "        v)))\n\n"
   
   ;; Hopf fibration helpers
   "(define (hopf-projection n point)\n"
   "  \"Project point using Hopf fibration rules\"\n"
   "  (case n\n"
   "    [(1) point]  ; SÂ¹ â†’ SÂ¹ (identity)\n"
   "    [(3) (complex-hopf point)]  ; SÂ³ â†’ SÂ²\n"
   "    [(7) (octonionic-hopf point)]  ; Sâ· â†’ Sâ´\n"
   "    [else point]))\n\n"
   
   "(define (complex-hopf point)\n"
   "  \"Complex Hopf fibration SÂ³ â†’ SÂ²\"\n"
   "  (match point\n"
   "    [(list z1 z2)\n"
   "     (let ([z1-conj (conjugate z1)]\n"
   "           [z2-conj (conjugate z2)])\n"
   "       (list (* 2 (* z1 z2-conj))\n"
   "             (- (* z1 z1-conj) (* z2 z2-conj))))]))\n\n"
   
   "(define (octonionic-hopf point)\n"
   "  \"Octonionic Hopf fibration Sâ· â†’ Sâ´\"\n"
   "  point)  ; Simplified for now\n\n"
   
   ;; CanvasL assembly helpers
   "(define (activate-node node-id context)\n"
   "  \"Activate a node in the CanvasL assembly\"\n"
   "  (hash-set context node-id 'active))\n\n"
   
   "(define (integrate-node node-id value context)\n"
   "  \"Integrate a value into a node\"\n"
   "  (hash-set context node-id value))\n\n"
   
   "(define (propagate-value from-node to-node value context)\n"
   "  \"Propagate value between nodes\"\n"
   "  (let* ([new-context (hash-set context to-node value)]\n"
   "         [from-val (hash-ref context from-node)])\n"
   "    (hash-set new-context from-node (list from-val value))))\n\n"
   
   "(define (observe-system context)\n"
   "  \"Observer pattern - collapse wavefunction via observation\"\n"
   "  (let ([entries (hash->list context)])\n"
   "    (map (lambda (entry) (car entry)) entries)))\n"))

;; Generate node processing functions
(define (generate-node-functions nodes edges)
  (if (empty? nodes)
      ";; No nodes defined\n"
      (string-append
       ";; ================================\n"
       ";; Node Processing Functions\n"
       ";; ================================\n\n"
       (apply string-append
              (map (lambda (node)
                     (let ([node-id (hash-ref node 'id)]
                           [node-type (hash-ref node 'type)]
                           [operation (hash-ref node 'operation "")]
                           [operands (hash-ref node 'operands '())])
                       (format
                        "(define (~a-process ~a)\n"
                        "  \"Process ~a node (~a)\"\n"
                        "  (match '~a\n"
                        "    ['activate (activate-node '~a context)]\n"
                        "    ['integrate (integrate-node '~a (first args) context)]\n"
                        "    ['transform (transform-node '~a args context)]\n"
                        "    ['propagate (propagate-node '~a args context)]\n"
                        "    ['verify (verify-node '~a args context)]\n"
                        "    ['store (store-node '~a args context)]\n"
                        "    ['observe (observe-node '~a context)]\n"
                        "    [else context]))\n\n"
                        (string->symbol (format "node-~a" node-id))
                        "context args"
                        node-type operation node-type
                        node-id
                        node-id
                        node-id
                        node-id
                        node-id
                        node-id
                        node-id
                        node-id)))
                   nodes)))))

;; Generate main orchestration functions
(define (generate-main-functions functions)
  (if (empty? functions)
      ";; No extracted functions\n"
      (string-append
       ";; ================================\n"
       ";; Main Orchestration Functions\n"
       ";; ================================\n\n"
       (apply string-append
              (map (lambda (func)
                     (let* ([func-name (hash-ref func 'name)]
                            [params (hash-ref func 'parameters '())]
                            [return-type (hash-ref func 'returnType 'any)]
                            [body (hash-ref func 'body '())]
                            [assembly-template (hash-ref func 'assemblyTemplate "")])
                       (string-append
                        (format "(define (~a ~a)\n" 
                                (string->symbol func-name)
                                (string-join (map (lambda (p) (format "~a" p)) params) " "))
                        (format "  \"Function: ~a\"\n" func-name)
                        (format "  \"Assembly Template: ~a\"\n" assembly-template)
                        (format "  \"Return Type: ~a\"\n\n" return-type)
                        "  (let ([context (make-hash)])\n"
                        "    ;; Initialize context\n"
                        "    (for ([(key value) (in-hash context)])\n"
                        "      (printf \"Initial: ~a = ~a~n\" key value))\n\n"
                        "    ;; Execute function body\n"
                        "    context)))\n\n")))
                   functions)))))

;; Generate entry point functions
(define (generate-entry-points entry-points)
  (if (empty? entry-points)
      ";; No entry points defined\n\n"
      (string-append
       ";; ================================\n"
       ";; Entry Points\n"
       ";; ================================\n\n"
       (apply string-append
              (map (lambda (entry)
                     (format
                      "(define (run-~a)\n"
                      "  \"Entry point: ~a\"\n"
                      "  (let ([initial-context (make-hash)])\n"
                      "    (~a-process initial-context '())))\n\n"
                      (hash-ref entry 'id)
                      (hash-ref entry 'id)
                      (hash-ref entry 'id)))
                   entry-points))
       
       ";; Main execution\n"
       "(define (main)\n"
       "  \"Main entry point for compiled CanvasL program\"\n"
       "  (printf \"CanvasL Program Starting...~n\")\n"
       "  (printf \"Mathematical Foundation: Division Algebras â„, â„‚, â„, ð•†~n\")\n"
       "  (printf \"Hopf Fibrations: SÂ¹ â†’ SÂ¹, SÂ³ â†’ SÂ², Sâ· â†’ Sâ´~n\")\n"
       "  (printf \"Dimensional Constraints: 1, 2, 4, 8 (Adams' Theorem)~n~n\")\n"
       "  (when (procedure? run-main)\n"
       "    (run-main))\n"
       "  (printf \"CanvasL Program Complete.~n\"))\n\n")))

;; =================================================================
;; DATA STRUCTURES
;; =================================================================

(struct ast-node 
  (id type operation operands metadata dependencies dependents children parents)
  #:transparent)

(struct ast
  (nodes edges functions variables entry-points exit-points metadata)
  #:transparent)

(struct compilation-result
  (success code errors warnings metadata)
  #:transparent)

;; =================================================================
;; LOGOS MATHEMATICAL CORE
;; =================================================================

;; Division algebra dimensions and properties
(define division-algebras
  (hash
   'â„ (hash 'dimension 1 'elements '("real") 'norm-squared identity)
   'â„‚ (hash 'dimension 2 'elements '("1" "i") 'norm-squared "aÂ² + bÂ²")
   'â„ (hash 'dimension 4 'elements '("1" "i" "j" "k") 'norm-squared "aÂ² + bÂ² + cÂ² + dÂ²")
   'ð•† (hash 'dimension 8 'elements '("eâ‚€" "eâ‚" "eâ‚‚" "eâ‚ƒ" "eâ‚„" "eâ‚…" "eâ‚†" "eâ‚‡") 'norm-squared "sum of squares")))

;; Hopf fibrations (based on Adams theorem)
(define hopf-fibrations
  (hash
   0 (hash 'source 0 'target 0 'fiber 0 'algebra 'â„)
   1 (hash 'source 1 'target 1 'fiber 0 'algebra 'â„‚)
   3 (hash 'source 3 'target 2 'fiber 1 'algebra 'â„)
   7 (hash 'source 7 'target 4 'fiber 3 'algebra 'ð•†)))

;; Node types mapping to assembly operations
(define node-mapping
  (hash
   'activate   (hash 'op 'JMP       'dimension 0  'assembly "JMP {target}")
   'integrate   (hash 'op 'ADD       'dimension 1  'assembly "ADD {dest}, {a}, {b}")
   'transform  (hash 'op 'MUL       'dimension 2  'assembly "MUL {dest}, {a}, {b}")
   'propagate  (hash 'op 'SHL       'dimension 3  'assembly "SHL {dest}, {value}, {count}")
   'verify     (hash 'op 'CMP       'dimension 4  'assembly "CMP {left}, {right}")
   'store      (hash 'op 'MOV       'dimension 5  'assembly "MOV [{addr}], {value}")
   'observe    (hash 'op 'LD        'dimension 6  'assembly "LD {dest}, [{addr}]")
   'data       (hash 'op 'NOP       'dimension 7  'assembly "NOP")))

;; =================================================================
;; AST PROCESSING
;; =================================================================

;; Convert JSON to AST structure
(define (json->ast json-ast)
  (define nodes (map json->ast-node (hash-ref json-ast 'nodes '())))
  (define edges (hash-ref json-ast 'edges '()))
  (define functions (hash-ref json-ast 'functions '()))
  (define variables (hash-ref json-ast 'variables '()))
  (define entry-points (hash-ref json-ast 'entryPoints '()))
  (define exit-points (hash-ref json-ast 'exitPoints '()))
  (define metadata (hash-ref json-ast 'metadata '()))
  
  (ast nodes edges functions variables entry-points exit-points metadata))

(define (json->ast-node json-node)
  (define id (hash-ref json-node 'id))
  (define type (hash-ref json-node 'type))
  (define operation (hash-ref json-node 'operation))
  (define operands (hash-ref json-node 'operands '()))
  (define metadata (hash-ref json-node 'metadata))
  (define dependencies (hash-ref json-node 'dependencies '()))
  (define dependents (hash-ref json-node 'dependents '()))
  (define children (hash-ref json-node 'children '()))
  (define parents (hash-ref json-node 'parents '()))
  
  (ast-node id type operation operands metadata dependencies dependents children parents))

;; Validate AST structure
(define (validate-ast ast)
  (define errors '())
  
  ;; Check for required fields
  (when (null? (ast-nodes ast))
    (set! errors (cons "AST must contain at least one node" errors)))
  
  ;; Check for cycles
  (define cycles (detect-cycles ast))
  (when (not (null? cycles))
    (set! errors (cons (format "Circular dependencies detected: ~a" cycles) errors)))
  
  ;; Check node validity
  (for ([node (in-list (ast-nodes ast))])
    (when (not (hash-has-key? node-mapping (ast-node-type node)))
      (set! errors (cons (format "Invalid node type: ~a" (ast-node-type node)) errors))))
  
  (values (null? errors) errors))

;; Detect circular dependencies using DFS
(define (detect-cycles ast)
  (define visited (make-hash))
  (define recursion-stack (make-hash))
  (define cycles '())
  
  (define (has-cycle node-id path)
    (when (hash-ref visited node-id #f)
      (when (hash-ref recursion-stack node-id #f)
        ;; Found a cycle
        (define cycle-start (index-of path node-id))
        (when cycle-start
          (set! cycles (cons (drop path cycle-start) cycles))))
      (return))
    
    (hash-set! visited node-id #t)
    (hash-set! recursion-stack node-id #t)
    
    (define node (find-node-by-id ast node-id))
    (when node
      (for ([child-id (in-list (ast-node-children node))])
        (has-cycle child-id (append path (list node-id)))))
    
    (hash-remove! recursion-stack node-id))
  
  (for ([node-id (in-list (ast-entry-points ast))])
    (has-cycle node-id '()))
  
  cycles)

(define (find-node-by-id ast node-id)
  (findf (Î» (node) (string=? (ast-node-id node) node-id))
         (ast-nodes ast)))

;; =================================================================
;; RACKET CODE GENERATION
;; =================================================================

;; Compile AST to Racket code
(define (compile-ast->racket ast options)
  (define start-time (current-inexact-milliseconds))
  
  (with-handlers ([exn:fail? (Î» (e) 
    (compilation-result 
      #f 
      "" 
      (list (format "Compilation error: ~a" (exn-message e))) 
      '() 
      (hash 'compilation-time 0 'output-language 'racket 'lines-generated 0)))])
  
  (define-values (valid? errors) (validate-ast ast))
  (when (not valid?)
    (return (compilation-result 
      #f 
      "" 
      errors 
      '() 
      (hash 'compilation-time 0 'output-language 'racket 'lines-generated 0))))
  
  (define racket-code (generate-racket-code ast options))
  (define end-time (current-inexact-milliseconds))
  
  (compilation-result 
    #t
    racket-code
    '()
    (generate-warnings ast)
    (hash 'compilation-time (- end-time start-time)
           'output-language 'racket
           'lines-generated (length (string-split racket-code "\n"))))))

;; Generate Racket code from AST
(define (generate-racket-code ast options)
  (define sections '())
  
  ;; Header with mathematical information
  (when (hash-ref options 'includeDebugInfo #t)
    (set! sections (cons (generate-header ast) sections)))
  
  ;; Imports
  (set! sections (cons (generate-imports ast) sections))
  
  ;; Variables
  (when (not (null? (ast-variables ast)))
    (set! sections (cons (generate-variables ast) sections)))
  
  ;; Functions
  (when (not (null? (ast-functions ast)))
    (set! sections (cons (generate-functions ast) sections)))
  
  ;; Node functions
  (set! sections (cons (generate-node-functions ast) sections))
  
  ;; Main execution
  (set! sections (cons (generate-main-execution ast) sections))
  
  (string-join (reverse sections) "\n\n"))

;; Generate header with mathematical context
(define (generate-header ast)
  (define metadata (ast-metadata ast))
  (define timestamp (date->string (current-date) #t))
  
  (format
    "#lang racket\n\n;; Generated by Logos Visual Compiler\n;; Source: ~a\n;; Generated: ~a\n;; Complexity: ~a\n;; Mathematical Structure:\n;; - Division Algebras: â„(1D), â„‚(2D), â„(4D), ð•†(8D)\n;; - Observer Node: Identity element at origin\n;; - Hopf Fibrations: Only possible in dimensions 0,1,3,7 (Adams theorem)\n;; - Eâ‚ˆ Lattice: 8-dimensional root system\n;; - Assembly Mapping: Visual â†’ Mathematical â†’ Computational"
    (hash-ref metadata 'sourceCanvas 'unknown)
    timestamp
    (hash-ref metadata 'complexity 'unknown)))

;; Generate imports
(define (generate-imports ast)
  (define imports '())
  
  ;; Add imports based on node types
  (define node-types (map ast-node-type (ast-nodes ast)))
  (when (member 'observe node-types)
    (set! imports (cons "(require racket/port)" imports)))
  (when (member 'integrate node-types)
    (set! imports (cons "(require racket/match)" imports)))
  
  (if (null? imports)
      ";; No external imports required"
      (string-join (reverse imports) "\n")))

;; Generate variables
(define (generate-variables ast)
  (define sections '(";; Variables"))
  
  (for ([var (in-list (ast-variables ast))])
    (define name (hash-ref var 'name))
    (define type (hash-ref var 'type "any"))
    (define value (hash-ref var 'value #f))
    
    (define decl (if value
                   (format "(define ~a ~a) ; ~a" name value type)
                   (format "(define ~a #f) ; ~a" name type)))
    (set! sections (cons decl sections)))
  
  (string-join (reverse sections) "\n"))

;; Generate function definitions
(define (generate-functions ast)
  (define sections '(";; Extracted Functions"))
  
  (for ([func (in-list (ast-functions ast))])
    (define name (hash-ref func 'name "unnamed"))
    (define params (hash-ref func 'parameters '()))
    (define return-type (hash-ref func 'returnType "any"))
    (define assembly (hash-ref func 'assemblyTemplate ""))
    
    (define func-def (format "(define (~a ~a) ~a"
                           name
                           (string-join params " ")
                           return-type))
    
    (define body (generate-function-body func))
    
    (set! sections (cons 
                   (format "~a\n~a\n  ; Assembly: ~a)" func-def body assembly)
                   sections)))
  
  (string-join (reverse sections) "\n"))

;; Generate node functions
(define (generate-node-functions ast)
  (define sections '(";; Node Functions"))
  
  (for ([node (in-list (ast-nodes ast))])
    (when (member (ast-node-type node) '(activate integrate transform propagate))
      (define func-name (string->symbol (format "node-~a" (ast-node-id node))))
      (define mapping (hash-ref node-mapping (ast-node-type node)))
      (define operation (hash-ref mapping 'op))
      
      (define func-def (format "(define (~a)\n  ; Node: ~a\n  ; Operation: ~a\n  ; Assembly: ~a\n  ; TODO: Implement ~a operation)"
                            func-name
                            (ast-node-id node)
                            (ast-node-type node)
                            operation
                            (hash-ref mapping 'assembly)))
      
      (set! sections (cons func-def sections))))
  
  (if (null? (cdr sections))
      ";; No node functions generated"
      (string-join (reverse sections) "\n\n")))

;; Generate function body based on type
(define (generate-function-body func)
  (define name (hash-ref func 'name ""))
  
  (cond
    [(string-contains? name "integrate")
     (define params (hash-ref func 'parameters '()))
     (if (>= (length params) 2)
         (format "  (+ ~a ~a)" (first params) (second params))
         "  ; Integration operation")]
    [(string-contains? name "transform")
     (define params (hash-ref func 'parameters '()))
     (if (>= (length params) 2)
         (format "  (* ~a ~a)" (first params) (second params))
         "  ; Transform operation")]
    [(string-contains? name "activate") "  (displayln \"Activation started\")"]
    [else "  ; Function body to be implemented"]))

;; Generate main execution flow
(define (generate-main-execution ast)
  (define sections '(";; Main Execution Flow"))
  
  ;; Add entry points
  (for ([entry-id (in-list (ast-entry-points ast))])
    (define entry-node (find-node-by-id ast entry-id))
    (when entry-node
      (define node-type (ast-node-type entry-node))
      (define mapping (hash-ref node-mapping node-type))
      
      (define execution-comment 
        (format ";; Entry point: ~a (~a)" entry-id node-type))
      
      (define execution-code 
        (case node-type
          ['activate (format "(~a)" (first (ast-node-operands entry-node)))]
          [else (format ";; Execute ~a node" node-type)]))
      
      (set! sections (cons execution-comment sections))
      (set! sections (cons execution-code sections))))
  
  ;; Add mathematical commentary
  (set! sections (cons "\n;; Mathematical Commentary:" sections))
  (set! sections (cons ";; The observer at origin (0,0) represents the identity element." sections))
  (set! sections (cons ";; Each node transformation preserves the mathematical invariants." sections))
  (set! sections (cons ";; Division algebra constraints ensure no zero divisors exist." sections))
  
  (string-join (reverse sections) "\n"))

;; Generate warnings
(define (generate-warnings ast)
  (define warnings '())
  
  ;; Check for complexity warnings
  (define metadata (ast-metadata ast))
  (when (equal? (hash-ref metadata 'complexity) 'complex)
    (set! warnings (cons "High complexity detected - consider refactoring" warnings)))
  
  warnings)

;; =================================================================
;; HTTP API HANDLERS
;; =================================================================

;; Health check endpoint
(define (health-handler request)
  (values
   (response/full
    200 #"OK"
    (current-seconds)
    #"application/json"
    (list (header #"Access-Control-Allow-Origin" #"*"))
    (jsexpr->string (hash 'status 'ok 'timestamp (current-seconds) 'server "Logos Racket Backend")))))

;; Info endpoint
(define (info-handler request)
  (values
   (response/full
    200 #"OK"
    (current-seconds)
    #"application/json"
    (list (header #"Access-Control-Allow-Origin" #"*"))
    (jsexpr->string 
      (hash 'name "Logos Racket Backend"
            'version "1.0.0"
            'mathematical-foundations 
            (hash 'division-algebras (hash-keys division-algebras)
                  'hopf-fibrations (hash-keys hopf-fibrations)
                  'observer-theory "Identity at origin (0,0)")
            'supported-operations (hash-keys node-mapping))))))

;; Compile endpoint
(define (compile-handler request)
  (define body (bytes->jsexpr (request-post-data/raw request)))
  (define ast-data (hash-ref body 'ast))
  (define options (hash-ref body 'options (hash 'outputLanguage 'racket 'includeDebugInfo #t 'optimizationLevel 1)))
  
  (define ast (json->ast ast-data))
  (define result (compile-ast->racket ast options))
  
  (define response-data
    (hash 'success (compilation-result-success result)
          'code (compilation-result-code result)
          'errors (compilation-result-errors result)
          'warnings (compilation-result-warnings result)
          'metadata (compilation-result-metadata result)))
  
  (values
   (response/full
    200 #"OK"
    (current-seconds)
    #"application/json"
    (list (header #"Access-Control-Allow-Origin" #"*"))
    (jsexpr->string response-data))))

;; Validate endpoint
(define (validate-handler request)
  (define body (bytes->jsexpr (request-post-data/raw request)))
  (define ast-data (hash-ref body 'ast))
  
  (with-handlers ([exn:fail? (Î» (e) 
    (values
     (response/full
      200 #"OK"
      (current-seconds)
      #"application/json"
      (list (header #"Access-Control-Allow-Origin" #"*"))
      (jsexpr->string 
        (hash 'valid #f 
              'errors (list (format "Validation error: ~a" (exn-message e))))))))))])
  
  (define ast (json->ast ast-data))
  (define-values (valid? errors) (validate-ast ast))
  
  (values
   (response/full
    200 #"OK"
    (current-seconds)
    #"application/json"
    (list (header #"Access-Control-Allow-Origin" #"*"))
    (jsexpr->string 
      (hash 'valid valid? 
            'errors errors)))))

;; CORS preflight handler
(define (cors-handler request)
  (values
   (response/full
    200 #"OK"
    (current-seconds)
    #"text/plain"
    (list (header #"Access-Control-Allow-Origin" #"*")
          (header #"Access-Control-Allow-Methods" #"POST, GET, OPTIONS")
          (header #"Access-Control-Allow-Headers" #"Content-Type")))))

;; =================================================================
;; SERVER CONFIGURATION
;; =================================================================

;; Define routes
(define-values (dispatch generate-url)
  (dispatch-rules
   [("") health-endpoint]  ; Root endpoint for health check
   [("health") health-endpoint]
   [("generate") #:method "post" generate-code-endpoint]
   [("generate") #:method "options" cors-endpoint]))

;; Start the server
(define (start-server [port 8080])
  (printf "ðŸŽ¯ Logos Racket Backend Server starting on port ~a...~n" port)
  (printf "ðŸ“ Mathematical Foundation: Division Algebras â„, â„‚, â„, ð•†~n")
  (printf "ðŸŒŠ Hopf Fibrations: SÂ¹ â†’ SÂ¹, SÂ³ â†’ SÂ², Sâ· â†’ Sâ´~n")
  (printf "ðŸ”¢ Dimensional Constraints: 1, 2, 4, 8 (Adams' Theorem)~n")
  (printf "ðŸ—ï¸  Eâ‚ˆ Lattice Structure: 240 vectors, Coxeter group~n")
  (printf "~nAPI Endpoints:~n")
  (printf "  GET  /health        - Server health check~n")
  (printf "  POST /generate      - Generate Racket code from AST~n")
  (printf "  OPTIONS /generate   - CORS preflight~n")
  (printf "~nServer ready at: http://localhost:~a~n" port)
  
  (serve/servlet dispatch
                 #:port port
                 #:listen-ip #"127.0.0.1"
                 #:servlet-path "/"
                 #:server-root-path (current-directory)
                 #:extra-files-path (current-directory)
                 #:servlet-regexp #rx""
                 #:command-line? #t))

;; Main entry point
(module+ main
  (define port (or (string->number (getenv "PORT")) 8080))
  (start-server port))

(define server-url "http://localhost:8080")
(define port 8080)

(define (start-server)
  (printf "ðŸš€ Starting Logos Racket Backend Server~%")
  (printf "ðŸ“¡ Server URL: ~a~%" server-url)
  (printf "ðŸ”— Health check: ~a/health~%" server-url)
  (printf "ðŸ“Š API endpoints:~%")
  (printf "   GET  /health      - Server health check~%")
  (printf "   GET  /info        - Server information~%")
  (printf "   POST /compile     - Compile AST to Racket~%")
  (printf "   POST /validate    - Validate AST structure~%")
  (printf "~%")
  (printf "ðŸŽ¨ Mathematical Foundation:~%")
  (printf "   Division Algebras: â„(1D), â„‚(2D), â„(4D), ð•†(8D)~%")
  (printf "   Hopf Fibrations: Only dimensions 0,1,3,7 (Adams theorem)~%")
  (printf "   Observer Node: Identity element at origin (0,0)~%")
  (printf "   Eâ‚ˆ Lattice: 8-dimensional mathematical structure~%")
  (printf "~%")
  (printf "âš¡ Server starting on port ~a...~%" port)
  
  (serve/servlet
   (lambda (request)
     (define path (url->string (request-uri request)))
     (cond
       [(string=? path "/health") (health-handler request)]
       [(string=? path "/info") (info-handler request)]
       [(string=? path "/compile") (compile-handler request)]
       [(string=? path "/validate") (validate-handler request)]
       [(string=? path "/") (cors-handler request)]
       [else 
        (values
         (response/full
          404 #"Not Found"
          (current-seconds)
          #"application/json"
          (list (header #"Access-Control-Allow-Origin" #"*"))
          (jsexpr->string (hash 'error "Endpoint not found"))))]))
   #:listen-ip #f
   #:port port
   #:command-line? #t))

;; Start server when run directly
(module+ main
  (start-server))