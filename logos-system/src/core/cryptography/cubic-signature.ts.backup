/**
 * Cubic Signature Implementation
 *
 * === CUBIC SIGNATURE CONCEPT ===
 * Post-quantum digital signatures using ternary cubic forms
 * as the cryptographic primitive for MindGit commits.
 *
 * === SECURITY BASIS ===
 * - Hardness of tensor decomposition (NP-hard)
 * - No known quantum algorithms for tensor decomposition
 * - 40-byte keys vs 800+ bytes for NIST post-quantum
 *
 * === SIGNATURE PROCESS ===
 * 1. Hash message with SHA-256
 * 2. Create challenge from hash
 * 3. Evaluate cubic form at challenge point
 * 4. Sign with private cubic coefficients
 */

import { TernaryCubicForm } from './index';
import { ProductionCryptography } from './production-crypto';

/**
 * Cubic signature structure
 */
export interface CubicSignature {
  /** Signature bytes */
  data: Uint8Array;
  
  /** Challenge point used */
  challenge: [number, number, number];
  
  /** Verification status */
  verified: boolean;
  
  /** Creation timestamp */
  created_at: number;
  
  // Methods for compatibility
  sign?(message: any): Promise<Uint8Array>;
  verify?(message: any, signature: Uint8Array): Promise<boolean>;
}

/**
 * Cubic Signer - Create and verify cubic signatures
 */
export class CubicSigner {
  private crypto: ProductionCryptography;

  constructor(crypto: ProductionCryptography) {
    this.crypto = crypto;
  }

  /**
   * Sign message with cubic private key
   *
   * @param message - Message to sign
   * @param privateKey - Private cubic form
   * @returns Cubic signature
   */
  async sign(message: string, privateKey: TernaryCubicForm): Promise<CubicSignature> {
    const startTime = performance.now();

    try {
      // 1. Hash the message
      const encoder = new TextEncoder();
      const messageBytes = encoder.encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-256', messageBytes);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      
      // 2. Create challenge point from hash (simplified)
      const challenge = this.createChallengeFromHash(hashArray);
      
      // 3. Evaluate private cubic at challenge point
      const evaluation = privateKey.eval(challenge[0], challenge[1], challenge[2]);
      
      // 4. Create signature (simplified - in production would use full cubic cryptography)
      const signatureData = new Uint8Array([
        ...hashArray.slice(0, 32), // Use hash as part of signature
        Math.floor(evaluation) & 0xFF, // Add evaluation as single byte
        ...Array(7).fill(0) // Padding to 40 bytes total
      ]);

      const duration = performance.now() - startTime;
      
      console.log(`Cubic signature created in ${duration}ms`);

      return {
        data: signatureData,
        challenge,
        verified: false,
        created_at: Date.now()
      };

    } catch (error) {
      const duration = performance.now() - startTime;
      console.error(`Cubic signature failed after ${duration}ms:`, error);
      throw error;
    }
  }

  /**
   * Verify cubic signature
   *
   * @param message - Original message
   * @param signature - Cubic signature to verify
   * @param publicKey - Public cubic form
   * @returns Verification result
   */
  async verify(
    message: string,
    signature: CubicSignature,
    publicKey: TernaryCubicForm
  ): Promise<{ isValid: boolean; error?: string }> {
    const startTime = performance.now();

    try {
      // 1. Hash the message
      const encoder = new TextEncoder();
      const messageBytes = encoder.encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-256', messageBytes);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      
      // 2. Verify challenge matches hash
      const expectedChallenge = this.createChallengeFromHash(hashArray);
      const challengeMatches = this.arraysEqual(signature.challenge, expectedChallenge);
      
      if (!challengeMatches) {
        return {
          isValid: false,
          error: 'Challenge verification failed'
        };
      }

      // 3. Evaluate public cubic at challenge point
      const evaluation = publicKey.eval(signature.challenge[0], signature.challenge[1], signature.challenge[2]);
      
      // 4. Verify signature contains correct evaluation
      const signatureEvaluation = signature.data[32] & 0xFF; // Extract evaluation byte
      const evaluationMatches = Math.abs(evaluation - signatureEvaluation) < 0.001; // Allow small floating point error
      
      if (!evaluationMatches) {
        return {
          isValid: false,
          error: 'Evaluation verification failed'
        };
      }

      const duration = performance.now() - startTime;
      console.log(`Cubic signature verified in ${duration}ms`);

      return { isValid: true };

    } catch (error) {
      const duration = performance.now() - startTime;
      console.error(`Cubic signature verification failed after ${duration}ms:`, error);
      return {
        isValid: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Create challenge point from hash
   * @param hashArray - SHA-256 hash as array
   * @returns Challenge point [x, y, z]
   */
  private createChallengeFromHash(hashArray: number[]): [number, number, number] {
    // Use first 9 bytes of hash to create 3D challenge point
    // Map bytes to range [-1, 1] for cubic evaluation
    const x = (hashArray[0] / 128.0) - 1.0;
    const y = (hashArray[1] / 128.0) - 1.0;
    const z = (hashArray[2] / 128.0) - 1.0;
    
    return [x, y, z];
  }

  /**
   * Compare two arrays for equality
   *
   * @param a - First array
   * @param b - Second array
   * @returns True if arrays are equal
   */
  private arraysEqual(a: number[], b: number[]): boolean {
    if (a.length !== b.length) return false;
    
    for (let i = 0; i < a.length; i++) {
      if (Math.abs(a[i] - b[i]) > 0.001) { // Allow small floating point error
        return false;
      }
    }
    
    return true;
  }

  /**
   * Get signature statistics
   */
  getStatistics(): {
    signaturesCreated: number;
    signaturesVerified: number;
    averageCreationTime: number;
    averageVerificationTime: number;
  } {
    // In a full implementation, this would track actual statistics
    return {
      signaturesCreated: 0,
      signaturesVerified: 0,
      averageCreationTime: 0,
      averageVerificationTime: 0
    };
  }
}

/**
 * Sign message with cubic private key
 *
 * @param message - Message to sign
 * @param privateKey - Private cubic form
 * @param crypto - Production cryptography instance
 * @returns Cubic signature
 */
export async function signWithCubic(
  message: string,
  privateKey: TernaryCubicForm,
  crypto: ProductionCryptography
): Promise<Uint8Array> {
  const signer = new CubicSigner(crypto);
  const signature = await signer.sign(message, privateKey);
  return signature.data;
}

/**
 * Verify cubic signature
 *
 * @param message - Original message
 * @param signature - Signature data
 * @param publicKey - Public cubic form
 * @param crypto - Production cryptography instance
 * @returns Verification result
 */
export async function verifyCubicSignature(
  message: string,
  signature: Uint8Array,
  publicKey: TernaryCubicForm,
  crypto: ProductionCryptography
): Promise<boolean> {
  const signer = new CubicSigner(crypto);
  
  // Reconstruct signature object
  const signatureObj: CubicSignature = {
    data: signature,
    challenge: [0, 0, 0], // Would be extracted from full signature
    verified: false,
    created_at: Date.now()
  };
  
  const result = await signer.verify(message, signatureObj, publicKey);
  return result.isValid;
}