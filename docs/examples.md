# Examples Gallery

Collection of CanvasL examples demonstrating various programming patterns and mathematical operations.

## üéØ Basic Examples

### 1. Spatial Hello World
**File**: `spatial-hello-world.json`

The simplest CanvasL program demonstrating basic node types and data flow.

```json
{
  "nodes": [
    {
      "id": "observer",
      "type": "text",
      "x": 0,
      "y": 0,
      "width": 80,
      "height": 30,
      "text": "#Observe: Start computation"
    },
    {
      "id": "input",
      "type": "text",
      "x": 150,
      "y": 0,
      "width": 100,
      "height": 30,
      "text": "#Integrate: Get user input"
    },
    {
      "id": "process",
      "type": "text",
      "x": 300,
      "y": 0,
      "width": 120,
      "height": 30,
      "text": "#Transform: Process data"
    },
    {
      "id": "output",
      "type": "text",
      "x": 450,
      "y": 0,
      "width": 100,
      "height": 30,
      "text": "#Activate: Display result"
    }
  ],
  "edges": [
    {
      "id": "flow1",
      "fromNode": "observer",
      "toNode": "input"
    },
    {
      "id": "flow2",
      "fromNode": "input",
      "toNode": "process"
    },
    {
      "id": "flow3",
      "fromNode": "process",
      "toNode": "output"
    }
  ]
}
```

**Compilation**:
```bash
mind-git compile examples/spatial-hello-world.json
```

**Generated JavaScript**:
```javascript
// Generated by CanvasL Visual Compiler v1.1.0
console.log("Hello from spatial programming!");
console.log("Nodes processed:", 4);
console.log("Edges processed:", 3);
```

## üßÆ Mathematical Examples

### 2. Polynomial Operations
**File**: `polynomial-operations.json`

Demonstrates polynomial algebra operations using CanvasL spatial arrangement.

```json
{
  "nodes": [
    {
      "id": "poly1",
      "type": "text",
      "x": 100,
      "y": 100,
      "text": "#Integrate: p1 = 1 + x¬≤"
    },
    {
      "id": "poly2", 
      "type": "text",
      "x": 300,
      "y": 100,
      "text": "#Integrate: p2 = 1 + x"
    },
    {
      "id": "multiply",
      "type": "text",
      "x": 200,
      "y": 200,
      "text": "#Transform: Multiply polynomials"
    },
    {
      "id": "result",
      "type": "text",
      "x": 400,
      "y": 200,
      "text": "#Activate: Display result"
    }
  ],
  "edges": [
    {"fromNode": "poly1", "toNode": "multiply"},
    {"fromNode": "poly2", "toNode": "multiply"},
    {"fromNode": "multiply", "toNode": "result"}
  ]
}
```

### 3. Identity Chain Operations
**File**: `identity-chain.json`

Demonstrates the complete identity chain from 2D to 8D operations.

```json
{
  "nodes": [
    {
      "id": "complex2d",
      "type": "text",
      "x": 100,
      "y": 300,
      "text": "#Transform: Brahmagupta 2D identity"
    },
    {
      "id": "quaternion4d",
      "type": "text", 
      "x": 300,
      "y": 300,
      "text": "#Transform: Euler 4D identity"
    },
    {
      "id": "octonion8d",
      "type": "text",
      "x": 500,
      "y": 300,
      "text": "#Transform: Degen 8D identity"
    },
    {
      "id": "verify",
      "type": "text",
      "x": 400,
      "y": 400,
      "text": "#Verify: Check norm preservation"
    }
  ],
  "edges": [
    {"fromNode": "complex2d", "toNode": "quaternion4d"},
    {"fromNode": "quaternion4d", "toNode": "octonion8d"},
    {"fromNode": "octonion8d", "toNode": "verify"}
  ]
}
```

## üé® Advanced Examples

### 4. Conditional Logic
**File**: `conditional-logic.json`

Demonstrates branching and decision-making in CanvasL.

```json
{
  "nodes": [
    {
      "id": "observer",
      "type": "text",
      "x": 0,
      "y": 0,
      "text": "#Observe: Start decision"
    },
    {
      "id": "condition",
      "type": "text",
      "x": 150,
      "y": 0,
      "text": "#BackPropagate: Check condition"
    },
    {
      "id": "branch-true",
      "type": "text",
      "x": 100,
      "y": 100,
      "text": "#Activate: Execute if true"
    },
    {
      "id": "branch-false",
      "type": "text",
      "x": 200,
      "y": 100,
      "text": "#Activate: Execute if false"
    },
    {
      "id": "merge",
      "type": "text",
      "x": 150,
      "y": 200,
      "text": "#Integrate: Merge results"
    }
  ],
  "edges": [
    {"fromNode": "observer", "toNode": "condition"},
    {"fromNode": "condition", "toNode": "branch-true"},
    {"fromNode": "condition", "toNode": "branch-false"},
    {"fromNode": "branch-true", "toNode": "merge"},
    {"fromNode": "branch-false", "toNode": "merge"}
  ]
}
```

### 5. Loop Structures
**File**: `loop-structures.json`

Demonstrates iteration and recursive patterns in CanvasL.

```json
{
  "nodes": [
    {
      "id": "observer",
      "type": "text",
      "x": 0,
      "y": 0,
      "text": "#Observe: Initialize loop"
    },
    {
      "id": "counter",
      "type": "text",
      "x": 150,
      "y": 0,
      "text": "#Store: Initialize counter"
    },
    {
      "id": "condition",
      "type": "text",
      "x": 300,
      "y": 0,
      "text": "#BackPropagate: Check loop condition"
    },
    {
      "id": "increment",
      "type": "text",
      "x": 200,
      "y": 100,
      "text": "#Integrate: Increment counter"
    },
    {
      "id": "loop-body",
      "type": "text",
      "x": 400,
      "y": 100,
      "text": "#Transform: Process loop body"
    },
    {
      "id": "exit-check",
      "type": "text",
      "x": 500,
      "y": 200,
      "text": "#BackPropagate: Check exit condition"
    },
    {
      "id": "output",
      "type": "text",
      "x": 600,
      "y": 200,
      "text": "#Activate: Display result"
    }
  ],
  "edges": [
    {"fromNode": "observer", "toNode": "counter"},
    {"fromNode": "counter", "toNode": "condition"},
    {"fromNode": "condition", "toNode": "increment"},
    {"fromNode": "condition", "toNode": "loop-body"},
    {"fromNode": "loop-body", "toNode": "exit-check"},
    {"fromNode": "increment", "toNode": "condition"},
    {"fromNode": "exit-check", "toNode": "output"}
  ]
}
```

### 6. Function Definition
**File**: `function-definition.json`

Demonstrates function creation and calling in CanvasL.

```json
{
  "nodes": [
    {
      "id": "observer",
      "type": "text",
      "x": 0,
      "y": 0,
      "text": "#Observe: Define function"
    },
    {
      "id": "function-def",
      "type": "text",
      "x": 150,
      "y": 0,
      "text": "#Store: Define square(x) function"
    },
    {
      "id": "function-call",
      "type": "text",
      "x": 300,
      "y": 0,
      "text": "#Integrate: Call square(5)"
    },
    {
      "id": "output",
      "type": "text",
      "x": 450,
      "y": 0,
      "text": "#Activate: Display result"
    }
  ],
  "edges": [
    {"fromNode": "observer", "toNode": "function-def"},
    {"fromNode": "function-def", "toNode": "function-call"},
    {"fromNode": "function-call", "toNode": "output"}
  ]
}
```

## üî¨ Specialized Examples

### 7. Hopf Fibration Optimization
**File**: `hopf-optimization.json`

Demonstrates automatic Hopf fibration optimization for compatible degrees.

```json
{
  "nodes": [
    {
      "id": "observer",
      "type": "text",
      "x": 0,
      "y": 0,
      "text": "#Observe: Hopf-compatible computation"
    },
    {
      "id": "hopf-degree1",
      "type": "text",
      "x": 100,
      "y": 100,
      "text": "#Transform: Degree 1 polynomial (S¬π ‚Üí S¬π)"
    },
    {
      "id": "hopf-degree3",
      "type": "text",
      "x": 300,
      "y": 100,
      "text": "#Transform: Degree 3 polynomial (S¬≥ ‚Üí S¬≤)"
    },
    {
      "id": "hopf-degree7",
      "type": "text",
      "x": 500,
      "y": 100,
      "text": "#Transform: Degree 7 polynomial (S‚Å∑ ‚Üí S‚Å¥)"
    },
    {
      "id": "optimize",
      "type": "text",
      "x": 300,
      "y": 200,
      "text": "#Verify: Apply Hopf optimization"
    }
  ],
  "edges": [
    {"fromNode": "observer", "toNode": "hopf-degree1"},
    {"fromNode": "observer", "toNode": "hopf-degree3"},
    {"fromNode": "observer", "toNode": "hopf-degree7"},
    {"fromNode": "hopf-degree1", "toNode": "optimize"},
    {"fromNode": "hopf-degree3", "toNode": "optimize"},
    {"fromNode": "hopf-degree7", "toNode": "optimize"}
  ]
}
```

### 8. Geometric Operations
**File**: `geometric-operations.json`

Demonstrates advanced geometric transformations and spatial reasoning.

```json
{
  "nodes": [
    {
      "id": "observer",
      "type": "text",
      "x": 0,
      "y": 0,
      "text": "#Observe: Initialize geometry"
    },
    {
      "id": "rotate",
      "type": "text",
      "x": 150,
      "y": 100,
      "text": "#Transform: Rotate coordinate system"
    },
    {
      "id": "scale",
      "type": "text",
      "x": 250,
      "y": 100,
      "text": "#Transform: Scale coordinates"
    },
    {
      "id": "translate",
      "type": "text",
      "x": 350,
      "y": 100,
      "text": "#Transform: Translate coordinates"
    },
    {
      "id": "project",
      "type": "text",
      "x": 450,
      "y": 200,
      "text": "#BackPropagate: Project to lower dimension"
    },
    {
      "id": "output",
      "type": "text",
      "x": 550,
      "y": 200,
      "text": "#Activate: Display result"
    }
  ],
  "edges": [
    {"fromNode": "observer", "toNode": "rotate"},
    {"fromNode": "rotate", "toNode": "scale"},
    {"fromNode": "scale", "toNode": "translate"},
    {"fromNode": "translate", "toNode": "project"},
    {"fromNode": "project", "toNode": "output"}
  ]
}
```

## üéØ Compilation Results

### Running Examples
```bash
# Compile all examples
for file in examples/*.json; do
  echo "Compiling $file..."
  mind-git compile "$file" -o "output-$(basename $file .json).js"
done

# Run generated JavaScript
node output-spatial-hello-world.js
node output-polynomial-operations.js
```

### Expected Output
Each example generates JavaScript code that:
1. **Preserves mathematical structure** of the canvas
2. **Executes the intended operations** in correct order
3. **Includes debug information** about the compilation process
4. **Maintains norm preservation** throughout execution

## üé® Creating Your Own Examples

### Design Principles
1. **Observer at Origin**: Always start with `#Observe:` node at (0,0)
2. **Clear Data Flow**: Arrange nodes left-to-right for execution order
3. **Appropriate Prefixes**: Use correct prefixes for intended operations
4. **Logical Connections**: Connect nodes to show clear dependencies
5. **Spatial Meaning**: Use position to encode mathematical relationships

### Best Practices
- **Start Simple**: Begin with basic data flow
- **Test Incrementally**: Verify each addition works
- **Document Intent**: Use clear node text descriptions
- **Use Colors**: Apply standard color coding for operations
- **Validate Structure**: Ensure no circular dependencies

---

**These examples demonstrate the full power of CanvasL's visual programming paradigm.** üéØ